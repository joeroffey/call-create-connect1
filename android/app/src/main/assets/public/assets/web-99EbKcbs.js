var t=(t,e,i)=>new Promise((r,o)=>{var n=t=>{try{d(i.next(t))}catch(e){o(e)}},s=t=>{try{d(i.throw(t))}catch(e){o(e)}},d=t=>t.done?r(t.value):Promise.resolve(t.value).then(n,s);d((i=i.apply(t,e)).next())});import{W as e,b as i,E as r}from"./index-Dn59gOu4.js";import"./ui-CsvuV3K5.js";import"./vendor-lUEIvSUi.js";import"./router-Bq3F0u5g.js";import"./supabase-C2sM_OHe.js";function o(t){const e=t.split("/").filter(t=>"."!==t),i=[];return e.forEach(t=>{".."===t&&i.length>0&&".."!==i[i.length-1]?i.pop():i.push(t)}),i.join("/")}class n extends e{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"],this.downloadFile=e=>t(this,null,function*(){var t,r;const o=i(e,e.webFetchExtra),n=yield fetch(e.url,o);let s;if(e.progress)if(null==n?void 0:n.body){const t=n.body.getReader();let i=0;const r=[],o=n.headers.get("content-type"),d=parseInt(n.headers.get("content-length")||"0",10);for(;;){const{done:o,value:n}=yield t.read();if(o)break;r.push(n),i+=(null==n?void 0:n.length)||0;const s={url:e.url,bytes:i,contentLength:d};this.notifyListeners("progress",s)}const l=new Uint8Array(i);let c=0;for(const e of r)void 0!==e&&(l.set(e,c),c+=e.length);s=new Blob([l.buffer],{type:o||void 0})}else s=new Blob;else s=yield n.blob();return{path:(yield this.writeFile({path:e.path,directory:null!==(t=e.directory)&&void 0!==t?t:void 0,recursive:null!==(r=e.recursive)&&void 0!==r&&r,data:s})).uri,blob:s}})}readFileInChunks(t,e){throw this.unavailable("Method not implemented.")}initDb(){return t(this,null,function*(){if(void 0!==this._db)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise((t,e)=>{const i=indexedDB.open(this.DB_NAME,this.DB_VERSION);i.onupgradeneeded=n.doUpgrade,i.onsuccess=()=>{this._db=i.result,t(i.result)},i.onerror=()=>e(i.error),i.onblocked=()=>{}})})}static doUpgrade(t){const e=t.target.result;t.oldVersion;e.objectStoreNames.contains("FileStorage")&&e.deleteObjectStore("FileStorage");e.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}dbRequest(e,i){return t(this,null,function*(){const t=-1!==this._writeCmds.indexOf(e)?"readwrite":"readonly";return this.initDb().then(r=>new Promise((o,n)=>{const s=r.transaction(["FileStorage"],t).objectStore("FileStorage")[e](...i);s.onsuccess=()=>o(s.result),s.onerror=()=>n(s.error)}))})}dbIndexRequest(e,i,r){return t(this,null,function*(){const t=-1!==this._writeCmds.indexOf(i)?"readwrite":"readonly";return this.initDb().then(o=>new Promise((n,s)=>{const d=o.transaction(["FileStorage"],t).objectStore("FileStorage").index(e)[i](...r);d.onsuccess=()=>n(d.result),d.onerror=()=>s(d.error)}))})}getPath(t,e){const i=void 0!==e?e.replace(/^[/]+|[/]+$/g,""):"";let r="";return void 0!==t&&(r+="/"+t),""!==e&&(r+="/"+i),r}clear(){return t(this,null,function*(){(yield this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()})}readFile(e){return t(this,null,function*(){const t=this.getPath(e.directory,e.path),i=yield this.dbRequest("get",[t]);if(void 0===i)throw Error("File does not exist.");return{data:i.content?i.content:""}})}writeFile(e){return t(this,null,function*(){const t=this.getPath(e.directory,e.path);let i=e.data;const r=e.encoding,o=e.recursive,n=yield this.dbRequest("get",[t]);if(n&&"directory"===n.type)throw Error("The supplied path is a directory.");const s=t.substr(0,t.lastIndexOf("/"));if(void 0===(yield this.dbRequest("get",[s]))){const t=s.indexOf("/",1);if(-1!==t){const i=s.substr(t);yield this.mkdir({path:i,directory:e.directory,recursive:o})}}if(!(r||i instanceof Blob||(i=i.indexOf(",")>=0?i.split(",")[1]:i,this.isBase64String(i))))throw Error("The supplied data is not valid base64 content.");const d=Date.now(),l={path:t,folder:s,type:"file",size:i instanceof Blob?i.size:i.length,ctime:d,mtime:d,content:i};return yield this.dbRequest("put",[l]),{uri:l.path}})}appendFile(e){return t(this,null,function*(){const t=this.getPath(e.directory,e.path);let i=e.data;const r=e.encoding,o=t.substr(0,t.lastIndexOf("/")),n=Date.now();let s=n;const d=yield this.dbRequest("get",[t]);if(d&&"directory"===d.type)throw Error("The supplied path is a directory.");if(void 0===(yield this.dbRequest("get",[o]))){const t=o.indexOf("/",1);if(-1!==t){const i=o.substr(t);yield this.mkdir({path:i,directory:e.directory,recursive:!0})}}if(!r&&!this.isBase64String(i))throw Error("The supplied data is not valid base64 content.");if(void 0!==d){if(d.content instanceof Blob)throw Error("The occupied entry contains a Blob object which cannot be appended to.");i=void 0===d.content||r?d.content+i:btoa(atob(d.content)+atob(i)),s=d.ctime}const l={path:t,folder:o,type:"file",size:i.length,ctime:s,mtime:n,content:i};yield this.dbRequest("put",[l])})}deleteFile(e){return t(this,null,function*(){const t=this.getPath(e.directory,e.path);if(void 0===(yield this.dbRequest("get",[t])))throw Error("File does not exist.");if(0!==(yield this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(t)])).length)throw Error("Folder is not empty.");yield this.dbRequest("delete",[t])})}mkdir(e){return t(this,null,function*(){const t=this.getPath(e.directory,e.path),i=e.recursive,r=t.substr(0,t.lastIndexOf("/")),o=(t.match(/\//g)||[]).length,n=yield this.dbRequest("get",[r]),s=yield this.dbRequest("get",[t]);if(1===o)throw Error("Cannot create Root directory");if(void 0!==s)throw Error("Current directory does already exist.");if(!i&&2!==o&&void 0===n)throw Error("Parent directory must exist");if(i&&2!==o&&void 0===n){const t=r.substr(r.indexOf("/",1));yield this.mkdir({path:t,directory:e.directory,recursive:i})}const d=Date.now(),l={path:t,folder:r,type:"directory",size:0,ctime:d,mtime:d};yield this.dbRequest("put",[l])})}rmdir(e){return t(this,null,function*(){const{path:t,directory:i,recursive:r}=e,o=this.getPath(i,t),n=yield this.dbRequest("get",[o]);if(void 0===n)throw Error("Folder does not exist.");if("directory"!==n.type)throw Error("Requested path is not a directory");const s=yield this.readdir({path:t,directory:i});if(0!==s.files.length&&!r)throw Error("Folder is not empty");for(const e of s.files){const o="".concat(t,"/").concat(e.name);"file"===(yield this.stat({path:o,directory:i})).type?yield this.deleteFile({path:o,directory:i}):yield this.rmdir({path:o,directory:i,recursive:r})}yield this.dbRequest("delete",[o])})}readdir(e){return t(this,null,function*(){const i=this.getPath(e.directory,e.path),r=yield this.dbRequest("get",[i]);if(""!==e.path&&void 0===r)throw Error("Folder does not exist.");const o=yield this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(i)]);return{files:yield Promise.all(o.map(e=>t(this,null,function*(){let t=yield this.dbRequest("get",[e]);return void 0===t&&(t=yield this.dbRequest("get",[e+"/"])),{name:e.substring(i.length+1),type:t.type,size:t.size,ctime:t.ctime,mtime:t.mtime,uri:t.path}})))}})}getUri(e){return t(this,null,function*(){const t=this.getPath(e.directory,e.path);let i=yield this.dbRequest("get",[t]);return void 0===i&&(i=yield this.dbRequest("get",[t+"/"])),{uri:(null==i?void 0:i.path)||t}})}stat(e){return t(this,null,function*(){const t=this.getPath(e.directory,e.path);let i=yield this.dbRequest("get",[t]);if(void 0===i&&(i=yield this.dbRequest("get",[t+"/"])),void 0===i)throw Error("Entry does not exist.");return{name:i.path.substring(t.length+1),type:i.type,size:i.size,ctime:i.ctime,mtime:i.mtime,uri:i.path}})}rename(e){return t(this,null,function*(){yield this._copy(e,!0)})}copy(e){return t(this,null,function*(){return this._copy(e,!1)})}requestPermissions(){return t(this,null,function*(){return{publicStorage:"granted"}})}checkPermissions(){return t(this,null,function*(){return{publicStorage:"granted"}})}_copy(e,i=!1){return t(this,null,function*(){let{toDirectory:n}=e;const{to:s,from:d,directory:l}=e;if(!s||!d)throw Error("Both to and from must be provided");n||(n=l);const c=this.getPath(l,d),a=this.getPath(n,s);if(c===a)return{uri:a};if(function(t,e){t=o(t),e=o(e);const i=t.split("/"),r=e.split("/");return t!==e&&i.every((t,e)=>t===r[e])}(c,a))throw Error("To path cannot contain the from path");let h;try{h=yield this.stat({path:s,directory:n})}catch(f){const t=s.split("/");t.pop();const e=t.join("/");if(t.length>0){if("directory"!==(yield this.stat({path:e,directory:n})).type)throw new Error("Parent directory of the to path is a file")}}if(h&&"directory"===h.type)throw new Error("Cannot overwrite a directory with a file");const u=yield this.stat({path:d,directory:l}),y=(e,i,r)=>t(this,null,function*(){const t=this.getPath(n,e),o=yield this.dbRequest("get",[t]);o.ctime=i,o.mtime=r,yield this.dbRequest("put",[o])}),p=u.ctime?u.ctime:Date.now();switch(u.type){case"file":{const t=yield this.readFile({path:d,directory:l});let e;i&&(yield this.deleteFile({path:d,directory:l})),t.data instanceof Blob||this.isBase64String(t.data)||(e=r.UTF8);const o=yield this.writeFile({path:s,directory:n,data:t.data,encoding:e});return i&&(yield y(s,p,u.mtime)),o}case"directory":{if(h)throw Error("Cannot move a directory over an existing object");try{yield this.mkdir({path:s,directory:n,recursive:!1}),i&&(yield y(s,p,u.mtime))}catch(f){}const t=(yield this.readdir({path:d,directory:l})).files;for(const e of t)yield this._copy({from:"".concat(d,"/").concat(e.name),to:"".concat(s,"/").concat(e.name),directory:l,toDirectory:n},i);i&&(yield this.rmdir({path:d,directory:l}))}}return{uri:a}})}isBase64String(t){try{return btoa(atob(t))==t}catch(e){return!1}}}n._debug=!0;export{n as FilesystemWeb};
